/*
[문제 설명]
구름 우주정거장은 좌표 (0, 0)에 있다.
특정 시간, 특정 좌표에서 미사일이 발사되고, 발사 지점으로부터 정거장까지 도달하기까지의 시간은
거리 * 2이다. 거리는 (x^2 + y^2)로 구할 수 있다.
특정시간에 부스터 시스템을 사용하면, 날아가고있는 미사일의 속도가 두배가 된다. (거리 1을 가는데 1의 시간 소요)
적절한 시간에 부스터 시스템을 사용하여 모든 미사일의 날아가는 시간의 합을 최소로 해야한다.
최소로 했을때 시간의 합을 구하는 문제.

[해결 과정]
날아가고있는 미사일의 개수가 최대일때 부스터 시스템을 사용하면 된다.
특정시간을 구할 필요는 없고, 특정 시간에 미사일 몇기가 날아가고 있는지만 알면된다.
가장 많은 미사일이 날아가고있을때의 미사일 개수를 구하기 위해, 미사일 발사, 착탄을 구분하여 관리한다.
변수 하나를 두고 0으로 초기화 한뒤, 미사일 정보를 시간기준으로 정렬하고, 발사 시 +1, 착탄 시 -1하여
값을 구한다.
단축시간은 미사일개수와 같으며, 결과는 부스터 시스템을 사용하지 않았을때의 시간의 합에서 단축시간을 빼서 구한다.

(04)              05 04 03 02 01 00 (10초)
(03)              01 00 (2초)
(02)     04 03 02 01 00 (8초)
(01)  02 01 00 (4초)
      00 01 02 03 04 05 06 07 08 09 10 11 12

2초(1*2)에 두 개의 미사일(4초, 8초) 단축 가능,
8초(4*2)에 세 개의 미사일(8초, 2초, 10초) 단축 가능.
부스터 시스템을 사용하지 않았을때의 합: 24초, 세 개의 미사일 단축.
24 - 3 = 1

사용하는 변수의 값이 int 범위를 초과할 수 있으므로 자료형 사용에 주의합니다.
*/

#include <cstdio>
#include <vector>
#include <utility>
#include <algorithm>
using namespace std;

int main() {
    int N;
    long long X, Y, T, duration, sum = 0;
    scanf("%d", &N);
    
    // 미사일은 발사, 착탄 두 종류가 있으니 N * 2크기 만큼 배열 선언.
    vector<pair<long long, int>> missiles(N * 2);
    for (int i = 0; i < N * 2; i += 2) {
        scanf("%lld %lld %lld", &X, &Y, &T);
        duration = (X * X + Y * Y) * 2; // 소요시간은 거리 * 2
        sum += duration; // 총 소요시간에 누적
        missiles[i] = { T, 1 }; // 발사시간, +1
        missiles[i + 1] = { T + duration, -1 }; // 착탄시간, -1
    }
    sort(missiles.begin(), missiles.end()); // 시간 기준으로 정렬
    long long current = 0, max = 0; // 현재 미사일, 최대 미사일
    for (auto missile : missiles) { // 하나씩 꺼내봄
        current += missile.second; // 발사인지, 착탄인지 구분하여 미사일 개수 누적
        if (current > max) max = current; // 현재 미사일이 최대미사일 보다 크다면 갱신
    }
    printf("%lld", sum - max); // 부스터 시스템을 사용하지 않았을때의 시간합에서 미사일 개수 차감
}